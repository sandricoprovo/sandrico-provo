# This file is automatically generated by Keystone, do not modify it manually.
# Modify your Keystone config when you want to change this.

type Content {
  id: ID!
  name: String
  subHeader: String
  text: Content_text_Document
}

type Content_text_Document {
  document(hydrateRelationships: Boolean! = false): JSON!
}

input ContentWhereUniqueInput {
  id: ID
}

input ContentWhereInput {
  AND: [ContentWhereInput!]
  OR: [ContentWhereInput!]
  NOT: [ContentWhereInput!]
  id: IDFilter
  name: StringFilter
  subHeader: StringFilter
}

input IDFilter {
  equals: ID
  in: [ID!]
  notIn: [ID!]
  lt: ID
  lte: ID
  gt: ID
  gte: ID
  not: IDFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input ContentOrderByInput {
  id: OrderDirection
  name: OrderDirection
  subHeader: OrderDirection
}

enum OrderDirection {
  asc
  desc
}

input ContentUpdateInput {
  name: String
  subHeader: String
  text: JSON
}

input ContentUpdateArgs {
  where: ContentWhereUniqueInput!
  data: ContentUpdateInput!
}

input ContentCreateInput {
  name: String
  subHeader: String
  text: JSON
}

type Section {
  id: ID!
  name: String
  page: String
  header: String
  subHeader: String
  content(
    where: ContentWhereInput! = {}
    orderBy: [ContentOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Content!]
  contentCount(where: ContentWhereInput! = {}): Int
  file: FileFieldOutput
  cta: String
}

interface FileFieldOutput {
  filename: String!
  filesize: Int!
  ref: String!
  url: String!
}

input SectionWhereUniqueInput {
  id: ID
}

type LocalFileFieldOutput implements FileFieldOutput {
  filename: String!
  filesize: Int!
  ref: String!
  url: String!
}

type CloudFileFieldOutput implements FileFieldOutput {
  filename: String!
  filesize: Int!
  ref: String!
  url: String!
}

input SectionWhereInput {
  AND: [SectionWhereInput!]
  OR: [SectionWhereInput!]
  NOT: [SectionWhereInput!]
  id: IDFilter
  name: StringFilter
  page: StringFilter
  header: StringFilter
  subHeader: StringFilter
  content: ContentManyRelationFilter
  cta: StringFilter
}

input ContentManyRelationFilter {
  every: ContentWhereInput
  some: ContentWhereInput
  none: ContentWhereInput
}

input SectionOrderByInput {
  id: OrderDirection
  name: OrderDirection
  page: OrderDirection
  header: OrderDirection
  subHeader: OrderDirection
  cta: OrderDirection
}

input SectionUpdateInput {
  name: String
  page: String
  header: String
  subHeader: String
  content: ContentRelateToManyForUpdateInput
  file: FileFieldInput
  cta: String
}

input ContentRelateToManyForUpdateInput {
  disconnect: [ContentWhereUniqueInput!]
  set: [ContentWhereUniqueInput!]
  create: [ContentCreateInput!]
  connect: [ContentWhereUniqueInput!]
}

input FileFieldInput {
  upload: Upload
  ref: String
}

"""
The `Upload` scalar type represents a file upload.
"""
scalar Upload

input SectionUpdateArgs {
  where: SectionWhereUniqueInput!
  data: SectionUpdateInput!
}

input SectionCreateInput {
  name: String
  page: String
  header: String
  subHeader: String
  content: ContentRelateToManyForCreateInput
  file: FileFieldInput
  cta: String
}

input ContentRelateToManyForCreateInput {
  create: [ContentCreateInput!]
  connect: [ContentWhereUniqueInput!]
}

type NavLink {
  id: ID!
  label: String
}

input NavLinkWhereUniqueInput {
  id: ID
}

input NavLinkWhereInput {
  AND: [NavLinkWhereInput!]
  OR: [NavLinkWhereInput!]
  NOT: [NavLinkWhereInput!]
  id: IDFilter
  label: StringFilter
}

input NavLinkOrderByInput {
  id: OrderDirection
  label: OrderDirection
}

input NavLinkUpdateInput {
  label: String
}

input NavLinkUpdateArgs {
  where: NavLinkWhereUniqueInput!
  data: NavLinkUpdateInput!
}

input NavLinkCreateInput {
  label: String
}

type NavBar {
  id: ID!
  logo: String
  label: String
  links(
    where: NavLinkWhereInput! = {}
    orderBy: [NavLinkOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [NavLink!]
  linksCount(where: NavLinkWhereInput! = {}): Int
}

input NavBarWhereUniqueInput {
  id: ID
}

input NavBarWhereInput {
  AND: [NavBarWhereInput!]
  OR: [NavBarWhereInput!]
  NOT: [NavBarWhereInput!]
  id: IDFilter
  logo: StringFilter
  label: StringFilter
  links: NavLinkManyRelationFilter
}

input NavLinkManyRelationFilter {
  every: NavLinkWhereInput
  some: NavLinkWhereInput
  none: NavLinkWhereInput
}

input NavBarOrderByInput {
  id: OrderDirection
  logo: OrderDirection
  label: OrderDirection
}

input NavBarUpdateInput {
  logo: String
  label: String
  links: NavLinkRelateToManyForUpdateInput
}

input NavLinkRelateToManyForUpdateInput {
  disconnect: [NavLinkWhereUniqueInput!]
  set: [NavLinkWhereUniqueInput!]
  create: [NavLinkCreateInput!]
  connect: [NavLinkWhereUniqueInput!]
}

input NavBarUpdateArgs {
  where: NavBarWhereUniqueInput!
  data: NavBarUpdateInput!
}

input NavBarCreateInput {
  logo: String
  label: String
  links: NavLinkRelateToManyForCreateInput
}

input NavLinkRelateToManyForCreateInput {
  create: [NavLinkCreateInput!]
  connect: [NavLinkWhereUniqueInput!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON
  @specifiedBy(
    url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf"
  )

type Mutation {
  createContent(data: ContentCreateInput!): Content
  createContents(data: [ContentCreateInput!]!): [Content]
  updateContent(
    where: ContentWhereUniqueInput!
    data: ContentUpdateInput!
  ): Content
  updateContents(data: [ContentUpdateArgs!]!): [Content]
  deleteContent(where: ContentWhereUniqueInput!): Content
  deleteContents(where: [ContentWhereUniqueInput!]!): [Content]
  createSection(data: SectionCreateInput!): Section
  createSections(data: [SectionCreateInput!]!): [Section]
  updateSection(
    where: SectionWhereUniqueInput!
    data: SectionUpdateInput!
  ): Section
  updateSections(data: [SectionUpdateArgs!]!): [Section]
  deleteSection(where: SectionWhereUniqueInput!): Section
  deleteSections(where: [SectionWhereUniqueInput!]!): [Section]
  createNavLink(data: NavLinkCreateInput!): NavLink
  createNavLinks(data: [NavLinkCreateInput!]!): [NavLink]
  updateNavLink(
    where: NavLinkWhereUniqueInput!
    data: NavLinkUpdateInput!
  ): NavLink
  updateNavLinks(data: [NavLinkUpdateArgs!]!): [NavLink]
  deleteNavLink(where: NavLinkWhereUniqueInput!): NavLink
  deleteNavLinks(where: [NavLinkWhereUniqueInput!]!): [NavLink]
  createNavBar(data: NavBarCreateInput!): NavBar
  createNavBars(data: [NavBarCreateInput!]!): [NavBar]
  updateNavBar(where: NavBarWhereUniqueInput!, data: NavBarUpdateInput!): NavBar
  updateNavBars(data: [NavBarUpdateArgs!]!): [NavBar]
  deleteNavBar(where: NavBarWhereUniqueInput!): NavBar
  deleteNavBars(where: [NavBarWhereUniqueInput!]!): [NavBar]
}

type Query {
  contents(
    where: ContentWhereInput! = {}
    orderBy: [ContentOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Content!]
  content(where: ContentWhereUniqueInput!): Content
  contentsCount(where: ContentWhereInput! = {}): Int
  sections(
    where: SectionWhereInput! = {}
    orderBy: [SectionOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Section!]
  section(where: SectionWhereUniqueInput!): Section
  sectionsCount(where: SectionWhereInput! = {}): Int
  navLinks(
    where: NavLinkWhereInput! = {}
    orderBy: [NavLinkOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [NavLink!]
  navLink(where: NavLinkWhereUniqueInput!): NavLink
  navLinksCount(where: NavLinkWhereInput! = {}): Int
  navBars(
    where: NavBarWhereInput! = {}
    orderBy: [NavBarOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [NavBar!]
  navBar(where: NavBarWhereUniqueInput!): NavBar
  navBarsCount(where: NavBarWhereInput! = {}): Int
  keystone: KeystoneMeta!
}

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  enableSignout: Boolean!
  enableSessionItem: Boolean!
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  itemQueryName: String!
  listQueryName: String!
  hideCreate: Boolean!
  hideDelete: Boolean!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  initialColumns: [String!]!
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  initialSort: KeystoneAdminUISort
  isHidden: Boolean!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  isOrderable: Boolean!
  isFilterable: Boolean!
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID): KeystoneAdminUIFieldMetaItemView
  search: QueryMode
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
